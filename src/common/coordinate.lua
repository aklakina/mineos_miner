---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/23/2024 10:13 AM
---

require('Logger')
local logger = Logger:new(Logger.levels.TRACE, "Coordinates")

axisToIndex = {
    x = 1,
    y = 2,
    z = 3
}

Direction = {}
Direction.__index = Direction

function Direction:new(name, num, vector)
    local newDirection = {}
    setmetatable(newDirection, self)
    self.__index = self
    newDirection.name = name
    newDirection.num = num
    newDirection.vector = vector
    return newDirection
end

directions = {
    forward = Direction:new("forward", 0, {0, 0, 1}),
    right = Direction:new("right", 1, {1, 0, 0}),
    back = Direction:new("back", 2, {0, 0, -1}),
    left = Direction:new("left", 3, {-1, 0, 0}),
    up = Direction:new("up", 0, {0, 1, 0}),
    down = Direction:new("down", 0, {0, -1, 0}),
    any = Direction:new("any", 0, {0, 0, 0}),
}

numToDirections = {
    [0] = directions.forward,
    [1] = directions.right,
    [2] = directions.back,
    [3] = directions.left
}

function directions.getDirectionFromNum(num)
    return numToDirections[num] or error("Invalid direction number")
end

function directions.getInverseDirection(direction)
    if getmetatable(direction) ~= Direction then
        direction = directions[direction]
    end
    return direction == directions.up and directions.down or direction == directions.down and directions.up or directions.getDirectionFromNum((direction.num + 2) % 4)
end

function directions.getDirectionFromName(name)
    return directions[name] or error("Invalid direction name")
end

function directions.convertToForward(direction)
    if getmetatable(direction) ~= Direction then
        direction = directions[direction]
    end
    if direction == directions.up or direction == directions.down then
        return direction
    else
        return directions.forward
    end
end

function directions.getInverseMovementVector(direction)
    if type(direction) == "string" then
        direction = directions[direction]
    end
    return direction.vector * -1
end

Axis = {
    x = {1, directions.right},
    y = {2, directions.up},
    z = {3, directions.forward},
}

Coordinate = {
    x = 0,
    y = 0,
    z = 0,
    direction = directions.forward,
}

function Coordinate.parse(o)
    if getmetatable(o) == Coordinate then
        return o
    elseif type(o) == "table" then
        if o.x and o.y and o.z then
            return Coordinate:new(o.x, o.y, o.z, o.direction or directions.any)
        elseif type(o[1]) == "number" and type(o[2]) == "number" and type(o[3]) == "number" then
            return Coordinate:new(o[1], o[2], o[3], o[4] or directions.any)
        else
            error("Invalid arguments for Coordinate.parse")
        end
    elseif o == nil then
        return nil
    else
        logger:error("Invalid arguments for Coordinate.parse, got: " .. type(o))
        error("Invalid arguments for Coordinate.parse")
    end
end

function Coordinate:new(x, y, z, direction)
    local newCoordinate = {}
    setmetatable(newCoordinate, self)
    self.__index = self
    newCoordinate.x = x
    newCoordinate.y = y
    newCoordinate.z = z
    newCoordinate.direction = direction
    return newCoordinate
end

-- Replace the movement vector with coordinates for easier use
directions.forward.vector = Coordinate:new(0, 0, 1, directions.forward)
directions.right.vector = Coordinate:new(1, 0, 0, directions.right)
directions.back.vector = Coordinate:new(0, 0, -1, directions.back)
directions.left.vector = Coordinate:new(-1, 0, 0, directions.left)
directions.up.vector = Coordinate:new(0, 1, 0, directions.up)
directions.down.vector = Coordinate:new(0, -1, 0, directions.down)
directions.any.vector = Coordinate:new(0, 0, 0, directions.any)

function Coordinate.__add(o, t)
    if not (getmetatable(t) == Coordinate) then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    return Coordinate:new(o.x + t.x, o.y + t.y, o.z + t.z, o.direction or directions.any)
end

function Coordinate.__mul(o, t)
    if not (getmetatable(t) == Coordinate or type(t) == "number") then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    if type(t) == "number" then
        return Coordinate:new(o.x * t, o.y * t, o.z * t, o.direction or directions.any)
    end
    return o.x * t.x + o.y * t.y + o.z * t.z
end

function Coordinate:__tostring()
    return "["..self.x..", "..self.y..", "..self.z.."]"
end

function Coordinate:isEqual(o)
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    if o == nil then
        return false
    end
    return self.x == o.x and self.y == o.y and self.z == o.z
end

function Coordinate.__eq(o, t)
    error("DEPRECATED")
    logger:debug("Comparing " .. tostring(o) .. " and " .. tostring(t))
    if getmetatable(t) ~= Coordinate then
        t = Coordinate.parse(t)
    end
    if getmetatable(o) ~= Coordinate then
        o = Coordinate.parse(o)
    end
    if o == nil and t == nil then
        return true
    elseif o == nil or t == nil then
        return false
    end
    return o.x == t.x and o.y == t.y and o.z == t.z
end

function Coordinate:isSimpleMovement(o)
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    if o == nil then
        return false
    end
    return (self.x == o.x and self.y == o.y) or (self.x == o.x and self.z == o.z) or (self.y == o.y and self.z == o.z)
end

Distance = {
    x = {direction = directions.right, distance = 0},
    y = {direction = directions.up, distance = 0},
    z = {direction = directions.forward, distance = 0},
    distance = Coordinate:new(0, 0, 0, directions.any)
}

function Distance.parse(o)
    if getmetatable(o) == Distance then
        return o
    elseif type(o) == "table" then
        if o.x and o.y and o.z then
            return Distance:new({0, 0, 0}, {o.x, o.y, o.z})
        elseif type(o[1]) == "number" and type(o[2]) == "number" and type(o[3]) == "number" then
            return Distance:new({0, 0, 0}, {o[1], o[2], o[3]})
        else
            error("Invalid arguments for Distance.parse")
        end
    elseif o == nil then
        return nil
    else
        logger:error("Invalid arguments for Distance.parse, got: " .. type(o))
        error("Invalid arguments for Distance.parse")
    end
end

function Distance:new(origin, target)
    if not (getmetatable(origin) == Coordinate) then
        origin = Coordinate.parse(origin)
    end
    if not (getmetatable(target) == Coordinate) then
        target = Coordinate.parse(target)
    end
    local _ret = {
        x = { direction = target.x - origin.x < 0 and directions.left or directions.right, distance = math.abs(target.x - origin.x)},
        y = { direction = target.y - origin.y < 0 and directions.down or directions.up, distance = math.abs(target.y - origin.y)},
        z = { direction = target.z - origin.z < 0 and directions.back or directions.forward, distance = math.abs(target.z - origin.z)},
        distance = Coordinate:new(target.x - origin.x, target.y - origin.y, target.z - origin.z, directions.any)
    }
    setmetatable(_ret, self)
    self.__index = self
    return _ret
end

function Distance:getAbsolute()
    return math.sqrt(self.distance * self.distance)
end

function Distance:isEqual(o)
    if not (getmetatable(o) == Distance) then
        o = Distance.parse(o)
    end
    if o == nil then
        return false
    end
    return self.distance:isEqual(o.distance)
end

function Distance:__tostring()
    return "[".. self.x.direction.name.. ": " ..self.x.distance..", "..self.y.direction.name.. ": " ..self.y.distance..", "..self.z.direction.name.. ": " ..self.z.distance.."]"
end

function Distance.merge(o, t)
    if not (getmetatable(o) == Distance) then
        o = Distance.parse(o)
    end
    if not (getmetatable(t) == Distance) then
        t = Distance.parse(t)
    end
    if o == nil or t == nil then
        return o and o or t
    end
    return Distance:new({0, 0, 0}, o.distance + t.distance)
end

function Distance.checkIfStraight(o, t)
    if not (getmetatable(o) == Distance) then
        o = Distance.parse(o)
    end
    if not (getmetatable(t) == Distance) then
        t = Distance.parse(t)
    end
    if o == nil or t == nil then
        return false
    end
    -- If the difference in the two distances is only on 1 axis and the other two are 0, then the two distances are straight
    return o.distance:isSimpleMovement(t.distance)
end

function Distance.fromPath(path)
    logger:debug("Merging straight movements")
    local distances = {}
    -- Every consecutive coordinate change on the same axis can be merged into one distance vector
    table.insert(distances, Distance:new(path[1], path[2]))
    for i = 3, #path do
        local dist = Distance:new(path[i-1], path[i])
        if not Distance.checkIfStraight(distances[#distances], dist) then
            table.insert(distances, dist)
            logger:debug("Movement: ".. tostring(path[i-1]) .. " to " .. tostring(path[i]) .. " is not straight from ".. tostring(path[i-2]) .. " to " .. tostring(path[i-1]) .. ". Adding new distance vector")
        else
            distances[#distances] = Distance.merge(distances[#distances], dist)
            logger:debug("Movement: ".. tostring(path[i-1]) .. " to " .. tostring(path[i]) .. " is straight from ".. tostring(path[i-2]) .. " to " .. tostring(path[i-1]) .. ". Merging distance vectors")
        end
    end
    logger:debug("Merged distances: ")
    for i, v in ipairs(distances) do
        logger:debug(tostring(v))
    end
    return distances
end