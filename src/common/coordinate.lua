---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/23/2024 10:13 AM
---

require('Logger')
local logger = Logger:new(Logger.levels.TRACE, "Coordinates")

axisToIndex = {
    x = 1,
    y = 2,
    z = 3
}

Direction = {}
Direction.__index = Direction

function Direction:new(name, num, vector)
    local newDirection = {}
    setmetatable(newDirection, self)
    self.__index = self
    newDirection.name = name
    newDirection.num = num
    newDirection.vector = vector
    return newDirection
end

directions = {
    forward = Direction:new("forward", 0, {0, 0, 1}),
    right = Direction:new("right", 1, {1, 0, 0}),
    back = Direction:new("back", 2, {0, 0, -1}),
    left = Direction:new("left", 3, {-1, 0, 0}),
    up = Direction:new("up", 0, {0, 1, 0}),
    down = Direction:new("down", 0, {0, -1, 0}),
    any = Direction:new("any", 0, {0, 0, 0}),
}

numToDirections = {
    [0] = directions.forward,
    [1] = directions.right,
    [2] = directions.back,
    [3] = directions.left
}

function directions.getDirectionFromNum(num)
    return numToDirections[num] or error("Invalid direction number")
end

function directions.getInverseDirection(direction)
    if getmetatable(direction) ~= Direction then
        direction = directions[direction]
    end
    return direction == directions.up and directions.down or direction == directions.down and directions.up or directions.getDirectionFromNum((direction.num + 2) % 4)
end

function directions.getDirectionFromName(name)
    return directions[name] or error("Invalid direction name")
end

function directions.convertToForward(direction)
    if getmetatable(direction) ~= Direction then
        direction = directions[direction]
    end
    if direction == directions.up or direction == directions.down then
        return direction
    else
        return directions.forward
    end
end

function directions.getInverseMovementVector(direction)
    if type(direction) == "string" then
        direction = directions[direction]
    end
    return direction.vector * -1
end

Axis = {
    x = {1, directions.right},
    y = {2, directions.up},
    z = {3, directions.forward},
}

Coordinate = {
    x = 0,
    y = 0,
    z = 0,
    direction = directions.forward,
}

function Coordinate.parse(o)
    if type(o) == "table" then
        if o.x and o.y and o.z then
            return Coordinate:new(o.x, o.y, o.z, o.direction or directions.any)
        elseif type(o[1]) == "number" and type(o[2]) == "number" and type(o[3]) == "number" then
            return Coordinate:new(o[1], o[2], o[3], o[4] or directions.any)
        else
            error("Invalid arguments for Coordinate.parse")
        end
    else
        error("Invalid arguments for Coordinate.parse")
    end
end

function Coordinate:new(x, y, z, direction)
    local newCoordinate = {}
    setmetatable(newCoordinate, self)
    self.__index = self
    newCoordinate.x = x
    newCoordinate.y = y
    newCoordinate.z = z
    newCoordinate.direction = direction
    return newCoordinate
end

-- Replace the movement vector with coordinates for easier use
directions.forward.vector = Coordinate:new(0, 0, 1, directions.forward)
directions.right.vector = Coordinate:new(1, 0, 0, directions.right)
directions.back.vector = Coordinate:new(0, 0, -1, directions.back)
directions.left.vector = Coordinate:new(-1, 0, 0, directions.left)
directions.up.vector = Coordinate:new(0, 1, 0, directions.up)
directions.down.vector = Coordinate:new(0, -1, 0, directions.down)
directions.any.vector = Coordinate:new(0, 0, 0, directions.any)

function Coordinate.__add(o, t)
    if not (getmetatable(t) == Coordinate) then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    return Coordinate:new(o.x + t.x, o.y + t.y, o.z + t.z, o.direction or directions.any)
end

function Coordinate.__mul(o, t)
    if not (getmetatable(t) == Coordinate or type(t) == "number") then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    if type(t) == "number" then
        return Coordinate:new(o.x * t, o.y * t, o.z * t, o.direction or directions.any)
    end
    return o.x * t.x + o.y * t.y + o.z * t.z
end

function Coordinate:__tostring()
    return "["..self.x..", "..self.y..", "..self.z.."]"
end

function Coordinate:__eq(o, t)
    if not (getmetatable(t) == Coordinate) then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parse(o)
    end
    return o.x == t.x and o.y == t.y and o.z == t.z
end

Distance = {
    x = {direction = directions.right, distance = 0},
    y = {direction = directions.up, distance = 0},
    z = {direction = directions.forward, distance = 0},
    distance = Coordinate:new(0, 0, 0, directions.any)
}

function Distance:new(t, o)
    if not (getmetatable(t) == Coordinate) then
        t = Coordinate.parse(t)
    end
    if not (getmetatable(o) == Coordinate) then
        o = Coordinate.parseInto(o)
    end
    local _ret = {
        x = {direction = o.x - t.x < 0 and directions.left or directions.right, distance = o.x - t.x},
        y = {direction = o.y - t.y < 0 and directions.down or directions.up, distance = o.y - t.y},
        z = {direction = o.z - t.z < 0 and directions.back or directions.forward, distance = o.z - t.z},
        distance = Coordinate:new(o.x - t.x, o.y - t.y, o.z - t.z, directions.any)
    }
    setmetatable(_ret, self)
    self.__index = self
    return _ret
end

function Distance:getAbsolute()
    return math.sqrt(self.distance * self.distance)
end
