---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/23/2024 10:13 AM
---

require('Logger')
local logger = Logger:new(Logger.levels.TRACE, "Coordinates")

axisToIndex = {
    x = 1,
    y = 2,
    z = 3
}

Direction = {}
Direction.__index = Direction

function Direction:new(name, num, vector)
    local newDirection = {}
    setmetatable(newDirection, self)
    self.__index = self
    newDirection.name = name
    newDirection.num = num
    newDirection.vector = vector
    return newDirection
end

directions = {
    forward = Direction:new("forward", 0, {0, 0, 1}),
    right = Direction:new("right", 1, {1, 0, 0}),
    back = Direction:new("back", 2, {0, 0, -1}),
    left = Direction:new("left", 3, {-1, 0, 0}),
    up = Direction:new("up", 0, {0, 1, 0}),
    down = Direction:new("down", 0, {0, -1, 0}),
    any = Direction:new("any", 0, {0, 0, 0}),
}

function directions.convertToForward(direction)
    if direction == directions.up or direction == directions.down then
        return direction
    else
        return directions.forward
    end
end

function directions.getInverseMovementVector(direction)
    if type(direction) == "string" then
        direction = directions[direction]
    end
    return direction.vector * -1
end

Axis = {
    x = {1, directions.right},
    y = {2, directions.up},
    z = {3, directions.forward},
}

Coordinate = {
    x = 0,
    y = 0,
    z = 0,
    direction = directions.forward,
}

function Coordinate.parseInto(o, t)
    if type(o) == "table" then
        if o.x and o.y and o.z then
            t = Coordinate:new(o.x, o.y, o.z, o.direction or directions.any)
        end
    end
    error("Invalid arguments for Coordinate.parse")
end

function Coordinate:new(x, y, z, direction)
    local newCoordinate = {}
    setmetatable(newCoordinate, self)
    self.__index = self
    newCoordinate.x = x
    newCoordinate.y = y
    newCoordinate.z = z
    newCoordinate.direction = direction
    return newCoordinate
end

-- Replace the movement vector with coordinates for easier use
directions.forward.vector = Coordinate:new(0, 0, 1, directions.forward)
directions.right.vector = Coordinate:new(1, 0, 0, directions.right)
directions.back.vector = Coordinate:new(0, 0, -1, directions.back)
directions.left.vector = Coordinate:new(-1, 0, 0, directions.left)
directions.up.vector = Coordinate:new(0, 1, 0, directions.up)
directions.down.vector = Coordinate:new(0, -1, 0, directions.down)
directions.any.vector = Coordinate:new(0, 0, 0, directions.any)

function Coordinate.__add(o, t)
    if not (getmetatable(t) == Coordinate) then
        Coordinate.parseInto(t, t)
    end
    if not (getmetatable(o) == Coordinate) then
        Coordinate.parseInto(o, o)
    end
    return Coordinate:new(o.x + t.x, o.y + t.y, o.z + t.z, o.direction or directions.any)
end

function Coordinate.__mul(o, t)
    if not (getmetatable(t) == Coordinate or type(t) == "number") then
        Coordinate.parseInto(t, t)
    end
    if not (getmetatable(o) == Coordinate) then
        Coordinate.parseInto(o, o)
    end
    if type(t) == "number" then
        return Coordinate:new(o.x * t, o.y * t, o.z * t, o.direction or directions.any)
    end
    return o.x * t.x + o.y * t.y + o.z * t.z
end

function Coordinate:__tostring()
    return "["..self.x..", "..self.y..", "..self.z.."]"
end

Distance = {
    x = {directions.right, 0},
    y = {directions.up, 0},
    z = {directions.forward, 0},
}

function Distance:new(o, t)
    -- Check if both origo and target are of type Coordinate
    if not (getmetatable(o) == Coordinate and getmetatable(t) == Coordinate) then
        -- Try to parse them as Coordinate
        if not (pcall(function() o = Coordinate:new(o.x, o.y, o.z, o.direction or directions.any) end) and pcall(function() t = Coordinate:new(t.x, t.y, t.z, t.direction  or directions.any) end)) then
            error("Invalid arguments for Distance constructor")
        end
    end
    local _ret = {
        x = {o.x - t.x < 0 and "left" or "right", o.x - t.x},
        y = {o.y - t.y < 0 and "down" or "up", o.y - t.y},
        z = {o.z - t.z < 0 and "back" or "forward", o.z - t.z},
    }
    setmetatable(_ret, self)
    self.__index = self
    return _ret
end

function Distance:getAbsolute()
    local dx = self.x[2]
    local dy = self.y[2]
    local dz = self.z[2]
    return math.sqrt(dx * dx + dy * dy + dz * dz)
end
