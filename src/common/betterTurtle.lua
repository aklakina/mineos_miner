---@diagnostic disable: undefined-field, undefined-global
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/18/2024 5:56 PM
---

require('Logger')
local logger = Logger:new(Logger.levels.INFO, "BetterTurtle")
require('mutex')

local numToDirection = {
    [0] = "forward",
    [1] = "right",
    [2] = "back",
    [3] = "left",
}

function isDirectionValid(direction)
    for k, v in pairs(directions) do
        if k == direction then
            return true
        end
    end
    error("Invalid direction", 2)
end

function getMethodNameForDirection(method, direction)
    if method ~= "" then
        if direction == "up" or direction == "down" then
            return method .. string.upper(string.sub(direction, 1, 1)) .. string.sub(direction, 2)
        else
            return method
        end
    else
        return direction
    end
end

function getMovementVector(direction)
    isDirectionValid(direction)
    return directions[direction][2]
end

function getYNormalizedDirection(direction)
    if direction == "up" or direction == "down" then
        return direction
    else
        return "forward"
    end
end

function getInverseDirection(direction)
    isDirectionValid(direction)
    if direction == "up" then
        return "down"
    elseif direction == "down" then
        return "up"
    else
        return numToDirection[(directions[direction][1] + 2) % 4]
    end
end

BetterTurtle = {
    position = {0, 0, 0},
    direction = "forward"
}

function BetterTurtle:turn(direction)
    logger:debug("Turning to " .. direction)
    logger:trace(self.direction .. " --> " .. direction)
    isDirectionValid(direction)
    local diff = (directions[direction][1] - directions[self.direction][1]) % 4
    logger:trace("Difference: " .. diff)
    if diff == 1 then
        turtle.turnRight()
    elseif diff == 2 then
        turtle.turnRight()
        turtle.turnRight()
    elseif diff == 3 then
        turtle.turnLeft()
    end
    self.direction = direction
    logger:debug("New direction: " .. self.direction)
    return diff
end

function BetterTurtle:relativeToGlobalDirection(direction)
    isDirectionValid(direction)
    if direction == "up" or direction == "down" then
        return direction
    end
    local globalOffset = directions[self.direction][1]
    local relativeOffset = directions[direction][1]
    logger:trace("Turtle's current direction: " .. self.direction)
    logger:trace("Relative direction: " .. direction)
    return numToDirection[(relativeOffset + globalOffset) % 4]
end

function BetterTurtle:relativeTurn(direction)
    --[[
    Turns the turtle in a relative direction
    :param direction: The relative direction to turn the turtle to
    ]]--
    logger:debug("Relative turn direction: " .. direction)
    logger:trace("Turning from " .. self.direction .. " to " .. self:relativeToGlobalDirection(direction))
    return self:turn(self:relativeToGlobalDirection(direction))
end

function BetterTurtle:new(o)
    o = o or {}
    -- Copy all methods from the turtle table to o
    for k, v in pairs(turtle) do
        o[k] = v
    end
    -- Set the metatable of o to BetterTurtle
    setmetatable(o, self)
    self.__index = self
    return o
end

function BetterTurtle:actionInDirection(action, direction)
    isDirectionValid(direction)
    local methodName = getMethodNameForDirection(action, direction)
    logger:debug("Calling turtle method: " .. methodName)
    return turtle[methodName]()
end

--[[
Digs in a direction
Does not move the turtle to the direction
:param direction: The direction to dig in
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:dig(direction, relative)
    if direction == nil then
        direction = self.direction
        logger:trace("Direction was nil, setting it to self.direction: " .. direction)
    end
    if relative == nil then
        relative = false
        logger:trace("Relative was nil, setting it to false")
    end
    logger:debug("Starting dig function with direction: " .. tostring(direction) .. " and relative: " .. tostring(relative))
    if relative then
        logger:debug("Relative is true, calling relativeTurn with direction: " .. direction)
        self:relativeTurn(direction)
    else
        logger:debug("Relative is false, calling turn with direction: " .. direction)
        self:turn(direction)
    end

    local result = self:actionInDirection("dig", direction)

    logger:info("Finished dig with result: " .. tostring(result))
    return result
end

--[[
Forces the turtle to dig in a direction
It will keep digging until the block is broken or it will attack if it is an entity
Does not move the turtle to the direction
:param direction: The direction to dig in
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:forceDig(direction, relative)
    if relative then
        self:relativeTurn(direction)
    else
        self:turn(direction)
    end
    while self:actionInDirection("dig", direction) do end
    while self:actionInDirection("attack", direction) do end
end

function BetterTurtle:offsetPosition(direction)
    local movementVector = getMovementVector(direction)
    return {self.position[1] + movementVector[1], self.position[2] + movementVector[2], self.position[3] + movementVector[3]}
end

function BetterTurtle:suckLava(direction, nLevel)
    local success, data = betterTurtle.actionInDirection("inspect", direction)
    if success and data.name == "minecraft:lava" then
        if betterTurtle.getFuelLevel() > 90000 then
            return false
        end
        Mutex:lock("suckLava")
        betterTurtle.select( 15 )
        if betterTurtle.actionInDirection("place", direction) then
            print( "[check]: Lava detected!" )
            if betterTurtle.refuel() then
                print( "[check]: Refueled using lava source!" )
                local lastDirection = betterTurtle.direction
                betterTurtle.move(direction, true)
                betterTurtle.select( 1 )
                Mutex:unlock("suckLava")
                check( nLevel + 1 )
                betterTurtle.move(getInverseDirection(lastDirection), true)
            else
                print( "[check]: Liquid was not lava!" )
                betterTurtle.place()
                betterTurtle.select( 1 )
                Mutex:unlock("suckLava")
            end
        end
    end
end

--[[
Moves the turtle in a direction
:param direction: The direction to move in
:param force: Whether to force the turtle to move, defaults to false
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:move(direction, force, relative)
    logger:debug("Starting move function with direction: " .. tostring(direction) .. ", force: " .. tostring(force) .. ", and relative: " .. tostring(relative))

    if direction == nil then
        direction = self.direction
        logger:trace("Direction was nil, setting it to self.direction: " .. direction)
    end
    if relative == nil then
        relative = false
        logger:trace("Relative was nil, setting it to false")
    end
    if force == nil then
        force = false
        logger:trace("Force was nil, setting it to false")
    end

    local moveMethodName = getMethodNameForDirection("", getYNormalizedDirection(direction))
    local movementVector = {}
    local globDirection = {}
    local relativeDirection = {}

    if relative then
        globDirection = self:relativeToGlobalDirection(direction)
        relativeDirection = direction
    else
        globDirection = direction
        relativeDirection = self:relativeToGlobalDirection(direction)
    end

    movementVector = getMovementVector(globDirection)

    if relativeDirection == "back" then
        movementVector = movementVector * -1
        moveMethodName = "back"
    end

    if moveMethodName ~= "back" then
        local rot = self:turn(globDirection)
        if rot > 0 then
            moveMethodName = getMethodNameForDirection("", "forward")
        end
    end
    if self:actionInDirection("", moveMethodName) then
        self.position:add(movementVector)
        logger:info("Move successful, new position: ".. self.position.tostring())
        return true
    elseif force then
        logger:trace("Force is true, calling forceDig with direction: " .. globDirection .. " and relative: " .. tostring(relative))
        self:forceDig(globDirection)
        movementVector = directions.getMovementVector(self.direction)
        self.position = self.position + movementVector
        logger:warn("Move was forced, new position: ".. self.position.tostring())
        return self:actionInDirection("", moveMethodName)
    else
        logger:error("Move failed")
        return false
    end
end

--[[
Moves the turtle to a position
:param position: The position to move to
:param force: Whether to force the turtle to move, defaults to false
--]]
function BetterTurtle:moveToPosition(position, force, order)
    local _order = order or {"y", "z", "x"}
    local distance = Distance:new(self.position, position)
    for _, axis in ipairs(_order) do
        if distance[axis][2] ~= 0 then
            local direction = distance[axis][1]
            local pos = axisToIndex[axis]
            logger:info("Moving in direction " .. direction .. " " .. distance[axis][2] .. " times")
            self:turn(direction)
            local relDirection = directions.convertToForward(direction)
            while self.position[pos] ~= position[pos] do
                if not self:move(relDirection, force, true) then
                    return false
                end
            end
        end
    end
    return true
end