---@diagnostic disable: undefined-field, undefined-global
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/18/2024 5:56 PM
---

require('Logger')
local logger = Logger:new(Logger.levels.DEBUG, "BetterTurtle")
require('mutex')
require('coordinate') -- Import the coordinate module

function isDirectionValid(direction)
    for k, v in pairs(directions) do
        if k == direction then
            return true
        end
    end
    error("Invalid direction", 2)
end

function getMethodNameForDirection(method, direction)
    if getmetatable(direction) ~= Direction then
        direction = directions.getDirectionFromName(direction)
    end
    if method ~= "" then
        if direction == directions.up or direction == directions.down then
            return method .. string.upper(string.sub(direction.name, 1, 1)) .. string.sub(direction.name, 2)
        else
            return method
        end
    else
        return direction.name
    end
end

BetterTurtle = {
    position = Coordinate:new(0, 0, 0, directions.forward), -- Use Coordinate for position
    direction = directions.forward
}

function BetterTurtle:turn(direction)
    if getmetatable(direction) ~= Direction then
        direction = directions.getDirectionFromName(direction)
    end
    logger:debug("Turning to " .. direction.name)
    logger:trace(self.direction.name .. " --> " .. direction.name)
    local diff = (direction.num - self.direction.num) % 4
    logger:trace("Difference: " .. diff)
    if diff == 1 then
        turtle.turnRight()
    elseif diff == 2 then
        turtle.turnRight()
        turtle.turnRight()
    elseif diff == 3 then
        turtle.turnLeft()
    end
    self.direction = direction
    logger:debug("New direction: " .. self.direction.name)
    return diff
end

function BetterTurtle:relativeToGlobalDirection(direction)
    local globalOffset = self.direction.num
    local relativeOffset = direction.num
    logger:trace("Turtle's current direction: " .. self.direction.name)
    logger:trace("Relative direction: " .. direction.name)
    if direction.num == 0 then
        return self.direction
    end
    return directions.getDirectionFromNum((relativeOffset + globalOffset) % 4)
end

function BetterTurtle:relativeTurn(direction)
    --[[
    Turns the turtle in a relative direction
    :param direction: The relative direction to turn the turtle to
    ]]--
    if getmetatable(direction) ~= Direction then
        direction = directions.getDirectionFromName(direction)
    end
    logger:debug("Relative turn direction: " .. direction.name)
    logger:trace("Turning from " .. self.direction.name .. " to " .. self:relativeToGlobalDirection(direction).name)
    return self:turn(self:relativeToGlobalDirection(direction))
end

function BetterTurtle:new(o)
    o = o or {}
    -- Copy all methods from the turtle table to o
    for k, v in pairs(turtle) do
        o[k] = v
    end
    -- Set the metatable of o to BetterTurtle
    setmetatable(o, self)
    self.__index = self
    return o
end

function BetterTurtle:actionInDirection(action, direction)
    if getmetatable(direction) ~= Direction then
        direction = directions.getDirectionFromName(direction)
    end
    local methodName = getMethodNameForDirection(action, direction)
    logger:debug("Calling turtle method: " .. methodName)
    return turtle[methodName]()
end

--[[
Digs in a direction
Does not move the turtle to the direction
:param direction: The direction to dig in
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:dig(direction, relative)
    if direction == nil then
        direction = self.direction
        logger:trace("Direction was nil, setting it to self.direction: " .. direction)
    end
    if relative == nil then
        relative = false
        logger:trace("Relative was nil, setting it to false")
    end
    logger:debug("Starting dig function with direction: " .. tostring(direction) .. " and relative: " .. tostring(relative))
    if relative then
        logger:debug("Relative is true, calling relativeTurn with direction: " .. direction)
        self:relativeTurn(direction)
    else
        logger:debug("Relative is false, calling turn with direction: " .. direction)
        self:turn(direction)
    end

    local result = self:actionInDirection("dig", direction)

    logger:info("Finished dig with result: " .. tostring(result))
    return result
end

--[[
Forces the turtle to dig in a direction
It will keep digging until the block is broken or it will attack if it is an entity
Does not move the turtle to the direction
:param direction: The direction to dig in
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:forceDig(direction, relative)
    if relative then
        self:relativeTurn(direction)
    else
        self:turn(direction)
    end
    while self:actionInDirection("dig", direction) do end
    while self:actionInDirection("attack", direction) do end
end

function BetterTurtle:offsetPosition(direction)
    return self.position + direction.vector
end

--[[
Moves the turtle in a direction
:param direction: The direction to move in
:param force: Whether to force the turtle to move, defaults to false
:param relative: Whether the direction is relative to the turtle's current direction, defaults to false
--]]
function BetterTurtle:move(direction, force, relative)
    if getmetatable(direction) ~= Direction then
        direction = directions.getDirectionFromName(direction)
    end
    logger:debug("Starting move function with direction: " .. tostring(direction.name) .. ", force: " .. tostring(force) .. ", and relative: " .. tostring(relative))

    local moveMethodName = getMethodNameForDirection("", directions.convertToForward(direction))
    local movementVector = {}
    local globDirection = {}
    local relativeDirection = {}

    if relative then
        globDirection = self:relativeToGlobalDirection(direction)
        relativeDirection = direction
    else
        globDirection = direction
        relativeDirection = self:relativeToGlobalDirection(direction)
    end

    movementVector = globDirection.vector

    if relativeDirection == directions.back then
        movementVector = movementVector * -1
        moveMethodName = "back"
    end

    if moveMethodName ~= "back" then
        local rot = self:turn(globDirection)
        if rot > 0 then
            moveMethodName = getMethodNameForDirection("", directions.forward)
        end
    end
    if self:actionInDirection("", moveMethodName) then
        self.position = self.position + movementVector
        logger:debug("Move successful, new position: ".. tostring(self.position))
        return true
    elseif force then
        logger:trace("Force is true, calling forceDig with direction: " .. globDirection.name .. " and relative: " .. tostring(relative))
        self:forceDig(globDirection)
        movementVector = self.direction.vector
        self.position = self.position + movementVector
        logger:warn("Move was forced, new position: ".. tostring(self.position))
        return self:actionInDirection("", moveMethodName)
    else
        logger:error("Move failed")
        return false
    end
end

--[[
Moves the turtle to a position
:param position: The position to move to
:param force: Whether to force the turtle to move, defaults to false
--]]
function BetterTurtle:moveToPosition(position, force, order)
    local _order = order or {"y", "z", "x"}
    if getmetatable(position) ~= Coordinate then
        position = Coordinate.parse(position)
    end
    local distance = Distance:new(self.position, position)
    for _, axis in ipairs(_order) do
        if distance[axis].distance ~= 0 then
            local direction = distance[axis].direction
            logger:info("Moving in direction " .. direction.name .. " " .. distance[axis].distance .. " times")
            self:turn(direction)
            local relDirection = directions.convertToForward(direction)
            while self.position[axis] ~= position[axis] do
                logger:debug("Target position: " .. tostring(position))
                logger:debug("Current position: " .. tostring(self.position))
                if not self:move(relDirection, force, true) then
                    return false
                end
            end
        end
    end
    return true
end

function BetterTurtle:findMaxLevel()
    local level = self.getFuelLevel()
    local maxFuel = 0
    if self.getItemCount( 16 ) > 1 then
        if not fuelAmount then
            self.select( 16 )
            self.refuel( 1 )
            fuelAmount = self.getFuelLevel() - level
            print( "[findMaxLevel]: Found fuelAmount: "..fuelAmount)
        end
        print( "[findMaxLevel]: Found max level: " .. self.getItemCount( 16 ) * fuelAmount + self.getFuelLevel() .. "!")
        maxFuel = self.getItemCount( 16 ) * fuelAmount + self.getFuelLevel()
    else
        print( "[findMaxLevel]: Found max level: " .. self.getFuelLevel() .. "!" )
        maxFuel = self.getFuelLevel()
    end
    if self.getItemCount( 15 ) > 0 then
        self.select( 15 )
        if self.refuel() then
            print( "[findMaxLevel]: Found lava, refueled by 1000!" )
            maxFuel = maxFuel + 1000
        end
    end
    return maxFuel
end

function BetterTurtle:moveDistance(distance)
    if getmetatable(distance) ~= Distance then
        distance = Distance.parse(distance)
    end
    local _order = {"y", "z", "x"}
    for _, axis in ipairs(_order) do
        if distance[axis].distance ~= 0 then
            local direction = distance[axis].direction
            logger:info("Moving in direction " .. direction.name .. " " .. distance[axis].distance .. " times")
            self:turn(direction)
            local relDirection = directions.convertToForward(direction)
            for i = 1, distance[axis].distance do
                if not self:move(relDirection, false, true) then
                    return false
                end
            end
        end
    end
end