---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/19/2024 7:41 PM
---

require('Logger')
local logger = Logger:new(Logger.levels.INFO, "Mutex")

Mutex = {
    func = nil,
    timeout = 6,
    queue = {},
    owner = nil,
    lock_count = 0,
    error_flag = false
}

function Mutex:new(timeout)
    local o = {timeout = timeout, queue = {}, owner = nil, lock_count = 0}
    setmetatable(o, self)
    self.__index = self
    return o
end

function Mutex:lock(func)
    local thread = coroutine.running()
    if self.owner == thread then
        self.lock_count = self.lock_count + 1
        return
    end
    table.insert(self.queue, thread)
    while self.func ~= nil or self.queue[1] ~= thread do
        if self.error_flag then
            error("Error was forced from another thread")
        end
        if coroutine.status(thread) == "dead" then
            return false
        end
        coroutine.yield()
    end
    table.remove(self.queue, 1)
    self.func = func
    self.owner = thread
    self.lock_count = 1
end

function Mutex:unlock(func)
    if self.func == func and self.owner == coroutine.running() then
        self.lock_count = self.lock_count - 1
        if self.lock_count == 0 then
            self.func = nil
            self.owner = nil
            if #self.queue > 0 then
                coroutine.resume(self.queue[1])
            end
        end
    end
end


mutex = Mutex:new(6)