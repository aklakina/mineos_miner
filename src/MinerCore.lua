---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by levi.
--- DateTime: 2/19/2024 7:28 PM
---

require('Logger')
local logger = Logger:new(Logger.levels.INFO, "MinerCore")

require('coordinate')
require('betterTurtle')
local betterTurtle = BetterTurtle:new()
local oldTurtle = betterTurtle
require('environment')
local environment = Environment:new()
require('mutex')

minerStates = {
    MINING = {},
    FUELING = {},
    NEEDS_FUEL = {},
    SEARCHING = {},
    RETURNING = {},
    STOPPING = {}
}

minerState = minerStates.SEARCHING

for i=-1, 1 do
    for j=-1, 1 do
        environment:insertCoordToCheckedBlocks(Coordinate:new(i, 0, j), blockType.BLOCKER)
    end
end

function loadConfig()
    local file = io.open("config.ini", "r")
    local config = {}

    for line in file:lines() do
        local key, value = string.match(line, "(%w+)%s-=%s-(%w+)")
        if key and value then
            config[key] = value
        end
    end

    file:close()
    return config
end

local config = loadConfig()
logger:info("Loaded config: {")
for key, value in pairs(config) do
    logger:info(key .. " = " .. value)
end
logger:info("}")

function dumpWaste()
    local num_dumped = 0
    logger:debug("[dumpWaste]: Dumping waste")
    for i = 1, 14 do
        local count = betterTurtle.getItemCount( i )
        local detail = betterTurtle.getItemDetail( i )
        if detail ~= nil and environment:checkBlockType(detail.name) == blockType.WASTE then
            logger:trace("[dumpWaste]: - "..detail.name.." (x"..count..")")
            betterTurtle.select( i )
            betterTurtle.drop( count )
            num_dumped = num_dumped + count
        end
    end
    if num_dumped == 0 then
        logger:trace("[dumpWaste]: No waste to dump")
    end
    logger:debug("[dumpWaste]: Dumped "..num_dumped.." items")
    betterTurtle.select( 1 )
    return num_dumped
end

function dumperLoop()
    while true do
        -- lock the mutex to prevent other threads from accessing the turtle
        Mutex:lock("dumperLoop")
        dumpWaste()
        -- unlock the mutex to allow other threads to access the turtle
        Mutex:unlock("dumperLoop")
        local id = os.startTimer( 20 )
        while true do
            local _, tid = os.pullEvent( "timer" )
            if tid == id then
                break
            end
        end
    end
end

function suckLava(direction, _blockType, blockPos)
    if _blockType == blockType.FUEL then
        if betterTurtle.getFuelLevel() > 90000 then
            logger:trace("[check]: Fuel level is high enough, not refueling")
            environment:storeFuelLocation(blockPos)
            minerState = minerStates.SEARCHING
            return false
        end
        Mutex:lock("suckLava")
        betterTurtle.select( 15 )
        if betterTurtle:actionInDirection("place", direction) then
            print( "[check]: Lava detected!" )
            if betterTurtle.refuel() then
                print( "[check]: Refueled using lava source!" )
                betterTurtle.select( 1 )
                if minerState ~= minerStates.RETURNING then
                    minerState = minerStates.FUELING
                end
                Mutex:unlock("suckLava")
                environment:removeFuelLocation(blockPos)
                return true
            else
                print( "[check]: Liquid was not lava!" )
                betterTurtle.place()
                betterTurtle.select( 1 )
                if minerState ~= minerStates.RETURNING then
                    minerState = minerStates.SEARCHING
                end
                Mutex:unlock("suckLava")
            end
        end
    end
    return false
end

function mineVein(_blockType)
    if _blockType == blockType.OTHER then
        mutex:lock("mineVein")
        if minerState ~= minerStates.RETURNING then
            minerState = minerStates.MINING
        end
        mutex:unlock("mineVein")
        return true
    else
        mutex:lock("mineVein")
        if minerState ~= minerStates.RETURNING then
            minerState = minerStates.SEARCHING
        end
        mutex:unlock("mineVein")
        return false
    end
end

local function suckInventory(direction)
    mutex:lock("suckInventory")
    if betterTurtle:actionInDirection("detect", direction) and betterTurtle:actionInDirection("inspect", direction) then
        while betterTurtle:actionInDirection("suck", direction) do end
        environment:insertCoordToCheckedBlocks(betterTurtle.offsetPosition(direction), blockType.BLOCKER)
        if minerState ~= minerStates.RETURNING then
            minerState = minerStates.SEARCHING
        end
        mutex:unlock("suckInventory")
        return false
    end
    mutex:unlock("suckInventory")
end

function check()
    while true do
        local pos
        for _, v in pairs(directions) do
            if minerState == minerStates.SEARCHING then
                local blockExists, blockData = betterTurtle:actionInDirection("inspect", v)
                local blockPos = betterTurtle:offsetPosition(v)
                local _blockType, checked = environment:checkBlock(blockPos, blockData)
                if not checked then
                    if blockExists then
                        if suckLava(v, _blockType, blockPos, nLevel) then pos = blockPos end
                        if mineVein(v, _blockType, blockPos, nLevel) then pos = blockPos end
                        suckInventory(v)
                    else
                        environment:insertCoordToCheckedBlocks(betterTurtle:offsetPosition(v), blockType.AIR)
                    end
                end
            else
                if minerState == minerStates.MINING or minerState == minerStates.RETURNING then
                    environment:addPositionToCheckQueue(betterTurtle:offsetPosition(v))
                elseif minerState == minerStates.FUELING then
                    environment:storeFuelLocation(betterTurtle:offsetPosition(v))
                elseif minerState == minerStates.NEEDS_FUEL then
                    local blockPos = betterTurtle:offsetPosition(v)
                    suckLava(v, blockType.FUEL, blockPos)
                    pos = blockPos
                end
            end
        end
        if minerState == minerStates.FUELING or minerState == minerStates.MINING then
            mutex:lock("check")
            betterTurtle:move(pos, true)
            environment:insertCoordToCheckedBlocks(betterTurtle.position, blockType.AIR)
            mutex:unlock("check")
        elseif minerState == minerStates.SEARCHING then
            break
        end
    end
end

function main()
    while minerState ~= minerStates.STOPPING do
        while minerState ~= minerStates.RETURNING do
            local directions = environment:getClosestMiningPositions(betterTurtle.position)
            mutex:lock("main")
            for _, v in pairs(directions) do
                betterTurtle:moveDistance(v)
            end
            mutex:unlock("main")
            if not pcall(check) then
                if mutex.error_flag then
                    logger:warn("[main]: Error was forced from another thread")
                    check()
                end
            end
        end
        --not ok, return to base
        print( "[main]: Returning to base!" )
        print ("[main]: At relative position: ".. tostring(betterTurtle.position))
        local directions = environment:dijkstra(betterTurtle.position, {0, 0, 0})
        mutex:lock("main")
        for _, v in pairs(directions) do
            betterTurtle:moveDistance(v)
        end
        mutex:unlock("main")
        print ("[main]: At relative position: ".. tostring(betterTurtle.position))
        print( "[main]: Returned to base!" )
        mutex:lock("main")
        for i = 1, 14 do
            betterTurtle.select( i )
            betterTurtle.dropDown()
        end
        betterTurtle.select( 1 )
        mutex:unlock("main")
        if minerState == minerStates.STOPPING then
            break
        end
    end

    for i = 1, 14 do
        betterTurtle.select( i )
        betterTurtle.dropDown()
    end
end

function isOk()
    while minerState ~= minerStates.STOPPING do
        local hasSpace = false
        mutex:lock("isOk")
        for i = 14, 1, -1 do
            if betterTurtle.getItemCount( i ) == 0 then
                hasSpace = true
                break
            end
        end
        betterTurtle.select( 1 )
        mutex:unlock("isOk")
        local manualInterrupt = false
        --Listen for RedNet manual interrupts
        if rednet.isOpen("left") then
            --Listen for RET
            local _, msg = rednet.receive(nil, 0.1)
            if msg == "RET" then
                manualInterrupt = true
            end
        end
        local needsFuel = betterTurtle.getFuelLevel() < 1000
        if needsFuel then
            mutex:lock("isOk")
            logger:info("[isOk]: Low fuel detected!  Initiating return!")
            environment:addPositionToCheckQueue(betterTurtle.position)
            minerState = minerStates.NEEDS_FUEL
            local directions, shouldContinue = environment:getNearestFuelLocation(betterTurtle.position)
            if shouldContinue then
                for _, v in pairs(directions) do
                    betterTurtle:moveDistance(v)
                end
                mutex.error_flag = true
            else
                minerState = minerStates.STOPPING
            end
            mutex:unlock("isOk")
        end
        if not hasSpace or manualInterrupt then
            mutex:lock("isOk")
            if not hasSpace then
                print( "[isOk]: Out of space!  Intiating return!" )
                minerState = minerStates.RETURNING
            end
            if manualInterrupt then
                print("[isOk]: Manual return requested!, Returning..")
                minerState = minerStates.STOPPING
            end
            mutex:unlock("isOk")
        end
        if minerState ~= STOPPING then
            print( "[isOk]: Everything is OK!" )
            local id = os.startTimer( 10 )
            while true do
                local _, tid = os.pullEvent( "timer" )
                if tid == id then
                    break
                end
            end
        end
    end
end

parallel.waitForAll( trackTime, isOk, dumpWaste, main )

function setTurtle(turtle)
    logger:error("This should only be used in a unit testing environment")
    betterTurtle = turtle
end

function resetTurtle()
    logger:error("This should only be used in a unit testing environment")
    betterTurtle = oldTurtle
end